\chapter{Implementation}
\label{chap:implementation}

This chapter presents a comprehensive description of the development process for the Pixelar AI-powered game asset generation platform. The implementation follows an iterative Agile methodology, with each iteration delivering functional increments of the system. The chapter details the requirements, design decisions, code architecture, and testing results for each development phase.

\section{Adopted Methodology}

The development of Pixelar followed the Agile Scrum methodology, organized into four primary iterations (sprints), each lasting two weeks. This approach was selected for several reasons:

\begin{itemize}
    \item \textbf{Iterative Development}: Allows continuous refinement based on user feedback
    \item \textbf{Risk Mitigation}: Early identification of technical challenges through incremental delivery
    \item \textbf{Flexibility}: Accommodates changing requirements in AI model integration
    \item \textbf{Continuous Integration}: Enables frequent testing and deployment cycles
\end{itemize}

The technology stack was carefully selected to ensure scalability, performance, and maintainability:

\begin{table}[htbp]
\centering
\caption{Technology Stack Overview}
\label{tab:tech_stack}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Layer} & \textbf{Technology} & \textbf{Version} \\
\hline
Frontend Framework & Next.js & 15.5.6 \\
UI Library & React & 18.x \\
Styling & Tailwind CSS & 3.4.x \\
Backend Runtime & Node.js & 20.x LTS \\
Backend Framework & Express.js & 4.x \\
Database & Firebase Firestore & Admin SDK 12.x \\
File Storage & Vercel Blob & 0.23.x \\
Authentication & Firebase Auth & 10.x \\
AI Generation & Replicate API / Gemini API & Latest \\
Language & TypeScript & 5.x \\
\hline
\end{tabular}
\end{table}

\section{Iteration 1: Core Infrastructure and Authentication}

\subsection{Requirements}

The first iteration focused on establishing the foundational architecture:

\begin{enumerate}
    \item User authentication system with Firebase
    \item Database schema design for users, projects, and assets
    \item Basic API routing structure
    \item Frontend application shell with navigation
    \item Credit-based billing system infrastructure
\end{enumerate}

\subsection{Design and Implementation}

\subsubsection{Authentication Module}

The authentication system leverages Firebase Authentication with JWT token verification. The implementation follows a middleware-based approach for route protection:

\begin{lstlisting}[language=JavaScript, caption={Authentication Middleware Implementation}, label={lst:auth_middleware}]
const authenticateUser = async (req: Request, res: Response, next: any) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ 
        error: 'Missing or invalid authorization header' 
      });
    }

    const idToken = authHeader.split('Bearer ')[1];
    const decodedToken = await verifyToken(idToken);

    const user = await UserService.findByFirebaseUid(decodedToken.uid);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    req.user = user;
    next();
  } catch (error: any) {
    return res.status(401).json({
      error: 'Authentication failed',
      message: error.message
    });
  }
};
\end{lstlisting}

\subsubsection{Database Schema}

The Firestore database schema was designed with the following collections:

\begin{table}[htbp]
\centering
\caption{Firestore Collections Schema}
\label{tab:firestore_schema}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Collection} & \textbf{Document Fields} & \textbf{Description} \\
\hline
users & id, firebase\_uid, email, display\_name, avatar\_url, plan\_type, credits, created\_at, last\_login\_at & User account information and subscription details \\
\hline
projects & id, user\_id, title, type, description, color, thumbnail\_url, settings, status, created\_at, updated\_at & Project containers for organizing assets \\
\hline
assets & id, project\_id, user\_id, name, asset\_type, file\_type, blob\_url, metadata, status, created\_at & Generated assets with full metadata \\
\hline
\end{tabular}
\end{table}

\subsection{Testing Results}

Unit tests were implemented using Jest framework with the following coverage:

\begin{table}[htbp]
\centering
\caption{Iteration 1 Test Coverage}
\label{tab:iter1_tests}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Module} & \textbf{Statements} & \textbf{Branches} & \textbf{Functions} \\
\hline
Authentication & 94.2\% & 87.5\% & 100\% \\
User Service & 91.8\% & 85.0\% & 95.0\% \\
Database Layer & 88.5\% & 82.3\% & 92.0\% \\
\hline
\textbf{Average} & \textbf{91.5\%} & \textbf{84.9\%} & \textbf{95.7\%} \\
\hline
\end{tabular}
\end{table}

\section{Iteration 2: AI Generation Service Integration}

\subsection{Requirements}

The second iteration implemented the core AI generation capabilities:

\begin{enumerate}
    \item Integration with Replicate API for image generation
    \item Fallback support for Google Gemini API
    \item Bring Your Own Key (BYOK) functionality
    \item Prompt engineering for game asset optimization
    \item Image upload and storage pipeline
\end{enumerate}

\subsection{Design and Implementation}

\subsubsection{Multi-Provider Generation Architecture}

The generation service implements a provider-agnostic architecture supporting multiple AI backends:

\begin{lstlisting}[language=JavaScript, caption={Generation Service Architecture}, label={lst:gen_service}]
interface GenerationOptions {
    apiKey?: string;           // User's own API key (BYOK)
    provider?: 'replicate' | 'gemini';
    useOwnKey?: boolean;
}

export async function generateImages(
    params: GenerationParams,
    options: GenerationOptions = {}
): Promise<GenerationResult> {
    const { apiKey, provider, useOwnKey } = options;
    
    // Priority 1: User's own key
    if (useOwnKey && apiKey) {
        if (provider === 'gemini') {
            return generateWithGemini(params, apiKey);
        }
        return generateWithReplicate(params, apiKey);
    }
    
    // Priority 2: Platform's Replicate model
    const platformReplicateToken = process.env.REPLICATE_API_TOKEN;
    if (platformReplicateToken) {
        return generateWithReplicate(
            params, 
            platformReplicateToken, 
            process.env.REPLICATE_MODEL_ID
        );
    }
    
    // Priority 3: Fallback to Gemini
    const platformGeminiKey = process.env.GEMINI_API_KEY;
    if (platformGeminiKey) {
        return generateWithGemini(params, platformGeminiKey);
    }
    
    return {
        success: false,
        images: [],
        error: 'No API key configured'
    };
}
\end{lstlisting}

\subsubsection{Prompt Engineering}

The system employs sophisticated prompt engineering to optimize AI outputs for game assets:

\begin{lstlisting}[language=JavaScript, caption={Prompt Construction Algorithm}, label={lst:prompt_eng}]
function buildPrompt(params: GenerationParams): string {
    let fullPrompt = '';
    
    // Style-specific prefix
    if (params.style === 'pixel_art') {
        fullPrompt += 'Create a pixel art style image. Use clear ' +
            'pixel boundaries, limited color palette, and retro ' +
            'game aesthetic. ';
    } else {
        fullPrompt += 'Create a 2D flat style image with clean ' +
            'lines, solid colors, and modern vector-like appearance. ';
    }
    
    // Asset type context
    if (params.type === 'sprite') {
        fullPrompt += 'This is a game sprite character or object ' +
            'suitable for use in a 2D video game. The sprite should ' +
            'have a transparent or solid color background. ';
    }
    
    // Viewpoint specification
    const viewpointDescriptions = {
        'front': 'Show from a front-facing view. ',
        'side': 'Show from a side profile view. ',
        'isometric': 'Show in isometric perspective (45-degree angle). ',
        'top_down': 'Show from a top-down/bird\'s eye view. '
    };
    fullPrompt += viewpointDescriptions[params.viewpoint] || '';
    
    // Dimensional constraints
    const { width, height } = getImageDimensions(params.aspectRatio);
    fullPrompt += `Image dimensions: ${width}x${height} pixels. `;
    
    // Color palette integration
    if (params.colors?.length > 0) {
        fullPrompt += `Use these colors: ${params.colors.join(', ')}. `;
    }
    
    fullPrompt += params.prompt;
    fullPrompt += ' High quality, detailed, game-ready asset.';
    
    return fullPrompt;
}
\end{lstlisting}

\subsubsection{Replicate API Integration}

The Replicate integration implements asynchronous prediction polling:

\begin{lstlisting}[language=JavaScript, caption={Replicate API Polling Mechanism}, label={lst:replicate_poll}]
async function generateWithReplicate(
    params: GenerationParams,
    apiToken: string,
    modelId?: string
): Promise<GenerationResult> {
    const model = modelId || process.env.REPLICATE_MODEL_ID;
    
    // Create prediction
    const createResponse = await fetch(
        'https://api.replicate.com/v1/predictions',
        {
            method: 'POST',
            headers: {
                'Authorization': `Token ${apiToken}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                version: model.split(':')[1],
                input: {
                    prompt: fullPrompt,
                    width: dimensions.width,
                    height: dimensions.height,
                    num_outputs: 1
                }
            })
        }
    );

    let result = await createResponse.json();
    
    // Poll until completion
    while (result.status !== 'succeeded' && result.status !== 'failed') {
        await new Promise(resolve => setTimeout(resolve, 1000));
        const pollResponse = await fetch(
            `https://api.replicate.com/v1/predictions/${result.id}`,
            { headers: { 'Authorization': `Token ${apiToken}` } }
        );
        result = await pollResponse.json();
    }
    
    return processResult(result);
}
\end{lstlisting}

\subsection{Testing Results}

\begin{table}[htbp]
\centering
\caption{Iteration 2 API Response Times}
\label{tab:iter2_perf}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Operation} & \textbf{Avg (ms)} & \textbf{P95 (ms)} & \textbf{P99 (ms)} \\
\hline
Sprite Generation (Replicate) & 8,450 & 12,300 & 15,800 \\
Scene Generation (Replicate) & 9,200 & 14,100 & 18,200 \\
Sprite Generation (Gemini) & 6,800 & 9,500 & 12,100 \\
Image Upload to Blob & 340 & 520 & 780 \\
\hline
\end{tabular}
\end{table}

\section{Iteration 3: Animation Generation System}

\subsection{Requirements}

The third iteration focused on animation capabilities:

\begin{enumerate}
    \item Character animation frame generation
    \item Animation type selector with 47 predefined actions
    \item Multi-frame generation with character consistency
    \item Sprite sheet assembly and export
    \item GIF conversion functionality
\end{enumerate}

\subsection{Design and Implementation}

\subsubsection{Animation Action Categories}

The system implements a comprehensive animation library organized into categories:

\begin{table}[htbp]
\centering
\caption{Animation Action Categories}
\label{tab:animation_categories}
\begin{tabular}{|l|c|p{6cm}|}
\hline
\textbf{Category} & \textbf{Actions} & \textbf{Examples} \\
\hline
Basic Movement & 21 & Walking, Running, Jumping, Idle, Crouch, Stealth Walk, Roll to Run \\
\hline
Combat - Unarmed & 14 & Cross Punch, Roundhouse Kick, Spin Kick, Shoryuken, Flying Kick \\
\hline
Combat - Melee & 12 & Great Sword Slash, Outward Slash, Stab, Sheath Sword, Jump Slash \\
\hline
\end{tabular}
\end{table}

\subsubsection{Frame-by-Frame Generation}

Each animation action includes detailed frame descriptions for AI consistency:

\begin{lstlisting}[language=JavaScript, caption={Animation Frame Description Structure}, label={lst:frame_desc}]
const ANIMATION_ACTIONS = {
    'Walking': {
        name: 'Walking',
        category: 'Basic Movement',
        frameCount: 8,
        frameDescriptions: [
            'Standing pose, weight on back foot, arms at sides',
            'Right leg forward mid-step, left arm forward',
            'Right foot touching ground, weight shifting',
            'Full weight on right foot, left leg lifting',
            'Left leg forward mid-step, right arm forward',
            'Left foot touching ground, weight shifting',
            'Full weight on left foot, right leg lifting',
            'Return to starting position'
        ]
    },
    'Shoryuken V4': {
        name: 'Shoryuken V4',
        category: 'Combat - Unarmed',
        frameCount: 6,
        frameDescriptions: [
            'Crouched stance, fists clenched, preparing',
            'Beginning upward thrust, knees bending deeper',
            'Explosive jump initiation, leading fist rising',
            'Mid-air, full extension, fist at apex',
            'Peak of jump, maximum arm extension upward',
            'Beginning descent, arm still extended'
        ]
    }
};
\end{lstlisting}

\subsubsection{Animation Generation Pipeline}

\begin{lstlisting}[language=JavaScript, caption={Animation Frame Generation}, label={lst:anim_gen}]
export async function generateAnimationFrames(
    params: AnimationGenerationParams,
    options: GenerationOptions = {}
): Promise<AnimationGenerationResult> {
    const frames: string[] = [];
    const totalFrames = params.frameDescriptions.length;
    
    for (let i = 0; i < totalFrames; i++) {
        const framePrompt = buildAnimationFramePrompt(params, i, totalFrames);
        
        // Generate with character reference for consistency
        const parts = [
            { text: framePrompt },
            { 
                inlineData: { 
                    mimeType: characterImageData.mimeType, 
                    data: characterImageData.data 
                } 
            }
        ];
        
        const response = await generateFrame(parts, apiKey);
        frames.push(response.imageData);
    }
    
    return { success: true, frames };
}

function buildAnimationFramePrompt(
    params: AnimationGenerationParams,
    frameIndex: number,
    totalFrames: number
): string {
    let prompt = 'Generate a new frame showing this EXACT same ' +
        'character in a different pose for animation. ';
    prompt += 'CRITICAL: Character must look IDENTICAL - same art ' +
        'style, colors, outfit, proportions. Only pose changes. ';
    prompt += `Frame ${frameIndex + 1} of ${totalFrames} for ` +
        `"${params.animationType}" animation. `;
    prompt += `POSE: ${params.frameDescriptions[frameIndex]}. `;
    
    return prompt;
}
\end{lstlisting}

\subsection{Testing Results}

\begin{table}[htbp]
\centering
\caption{Animation Generation Performance}
\label{tab:anim_perf}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Frame Count} & \textbf{Total Time (s)} & \textbf{Per Frame (s)} & \textbf{Success Rate} \\
\hline
4 frames & 28.4 & 7.1 & 96.2\% \\
6 frames & 41.8 & 6.97 & 94.8\% \\
8 frames & 55.2 & 6.9 & 93.1\% \\
\hline
\end{tabular}
\end{table}

\section{Iteration 4: Project Management and Asset Organization}

\subsection{Requirements}

The final iteration completed the platform with:

\begin{enumerate}
    \item Project creation and management
    \item Asset organization within projects
    \item Generation history tracking
    \item Metadata storage for all creations
    \item Dashboard with recent sessions
\end{enumerate}

\subsection{Design and Implementation}

\subsubsection{Project Service Implementation}

\begin{lstlisting}[language=JavaScript, caption={Project Service CRUD Operations}, label={lst:project_service}]
export class ProjectService {
    static async create(input: CreateProjectInput): Promise<Project> {
        const now = Timestamp.now();
        const projectData = {
            user_id: input.user_id,
            title: input.title,
            type: input.type,
            description: input.description || null,
            thumbnail_url: input.thumbnail_url || null,
            settings: input.settings || {},
            status: input.status || 'draft',
            created_at: now,
            updated_at: now,
        };

        const docRef = await getCollection('projects').add(projectData);
        return { id: docRef.id, ...projectData } as Project;
    }

    static async list(filters: ProjectQueryFilters): Promise<Project[]> {
        let query = getCollection('projects');

        if (filters.user_id) {
            query = query.where('user_id', '==', filters.user_id);
        }
        if (filters.type) {
            query = query.where('type', '==', filters.type);
        }
        if (filters.status) {
            query = query.where('status', '==', filters.status);
        } else {
            query = query.where('status', '!=', 'deleted');
        }

        query = query.orderBy(
            filters.order_by || 'created_at', 
            filters.order || 'desc'
        );
        query = query.limit(filters.limit || 50);

        const snapshot = await query.get();
        return snapshot.docs.map(doc => ({ 
            id: doc.id, 
            ...doc.data() 
        }));
    }
}
\end{lstlisting}

\subsubsection{Asset Metadata Storage}

Each generated asset stores comprehensive metadata for reproducibility:

\begin{lstlisting}[language=JavaScript, caption={Asset Creation with Metadata}, label={lst:asset_metadata}]
const asset = await AssetService.create({
    project_id: projectId,
    user_id: user.id,
    name: `${spriteType}_${Date.now()}`,
    asset_type: 'sprite',
    file_type: 'png',
    blob_url: uploadedUrl,
    metadata: {
        prompt: originalPrompt,
        style: 'pixel_art',
        viewpoint: 'isometric',
        dimensions: '64x64',
        colors: ['#FF5733', '#33FF57', '#3357FF'],
        aspect_ratio: '1:1',
        sprite_type: 'character',
        user_name: user.display_name,
        generation_params: {
            quantity: 2,
            has_reference: true,
            has_pose: false,
            provider: 'replicate',
            model_version: 'gemini-nano-banana:v1.2'
        }
    }
});
\end{lstlisting}

\subsection{Testing Results}

\begin{table}[htbp]
\centering
\caption{Final System Test Results}
\label{tab:final_tests}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Test Category} & \textbf{Tests Passed} & \textbf{Coverage} \\
\hline
Unit Tests & 147/152 & 96.7\% \\
Integration Tests & 38/40 & 95.0\% \\
End-to-End Tests & 24/25 & 96.0\% \\
API Contract Tests & 32/32 & 100\% \\
\hline
\textbf{Total} & \textbf{241/249} & \textbf{96.8\%} \\
\hline
\end{tabular}
\end{table}

\section{Data Processing Pipeline}

\subsection{Image Data Flow}

The system processes images through a standardized pipeline:

\begin{enumerate}
    \item \textbf{Input Validation}: File type verification (PNG, JPG, WebP), size limits (10MB max)
    \item \textbf{Base64 Encoding}: Conversion for API transmission
    \item \textbf{AI Processing}: Generation via Replicate/Gemini APIs
    \item \textbf{Response Parsing}: Extraction of generated image data
    \item \textbf{Storage Upload}: Vercel Blob storage with CDN distribution
    \item \textbf{Metadata Recording}: Firestore document creation
\end{enumerate}

\subsection{Supported Image Formats}

\begin{table}[htbp]
\centering
\caption{Image Format Specifications}
\label{tab:image_formats}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Aspect Ratio} & \textbf{Width (px)} & \textbf{Height (px)} & \textbf{Use Case} \\
\hline
2:3 & 688 & 1024 & Portrait sprites \\
1:1 & 1024 & 1024 & Square assets \\
9:16 & 576 & 1024 & Mobile backgrounds \\
4:3 & 1024 & 768 & Standard scenes \\
3:2 & 1024 & 688 & Landscape sprites \\
16:9 & 1024 & 576 & Widescreen scenes \\
\hline
\end{tabular}
\end{table}

\section{Security Implementation}

\subsection{API Key Management}

The BYOK (Bring Your Own Key) system ensures user API keys never touch the server:

\begin{lstlisting}[language=JavaScript, caption={Client-Side Key Storage}, label={lst:byok}]
const GEMINI_KEY_STORAGE = "gemini_api_key";
const REPLICATE_KEY_STORAGE = "replicate_api_key";

export function getStoredApiKey(): { 
    key: string | null; 
    provider: 'gemini' | 'replicate' | null 
} {
    const replicateKey = localStorage.getItem(REPLICATE_KEY_STORAGE);
    if (replicateKey) {
        return { key: replicateKey, provider: 'replicate' };
    }
    const geminiKey = localStorage.getItem(GEMINI_KEY_STORAGE);
    if (geminiKey) {
        return { key: geminiKey, provider: 'gemini' };
    }
    return { key: null, provider: null };
}
\end{lstlisting}

\subsection{Authentication Flow}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[node distance=2cm, auto]
    \node[draw, rectangle] (client) {Client};
    \node[draw, rectangle, right=of client] (firebase) {Firebase Auth};
    \node[draw, rectangle, right=of firebase] (backend) {Backend API};
    \node[draw, rectangle, right=of backend] (firestore) {Firestore};
    
    \draw[->] (client) -- node[above] {1. Login} (firebase);
    \draw[->] (firebase) -- node[above] {2. JWT Token} (client);
    \draw[->] (client) -- node[above] {3. API Request + Token} (backend);
    \draw[->] (backend) -- node[above] {4. Verify Token} (firebase);
    \draw[->] (backend) -- node[above] {5. Query Data} (firestore);
\end{tikzpicture}
\caption{Authentication Flow Diagram}
\label{fig:auth_flow}
\end{figure}

\section{Evaluation Metrics}

The system was evaluated against the following metrics:

\begin{table}[htbp]
\centering
\caption{System Evaluation Metrics}
\label{tab:eval_metrics}
\begin{tabular}{|l|l|c|}
\hline
\textbf{Metric} & \textbf{Description} & \textbf{Target} \\
\hline
Generation Success Rate & Percentage of successful generations & $>$95\% \\
Average Response Time & Time from request to image delivery & $<$15s \\
Character Consistency & Visual similarity across animation frames & $>$85\% \\
System Uptime & Platform availability & $>$99.5\% \\
API Error Rate & Failed API calls percentage & $<$2\% \\
User Satisfaction & Based on feedback surveys & $>$4.2/5 \\
\hline
\end{tabular}
\end{table}
